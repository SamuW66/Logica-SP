Este proyecto fue diseñado de manera estructurada para mostrar cómo funciona un sistema bancario básico, construido con una organización clara y separando las responsabilidades en diferentes capas. Todo comienza con la clase principal, que se encarga de iniciar la aplicación y preparar el entorno para que el resto de los componentes puedan operar de forma ordenada. Desde ahí, las peticiones del usuario son manejadas por distintas partes del sistema que cooperan entre sí, haciendo que el código sea fácil de entender, mantener y extender en el futuro.

La capa que se encuentra en contacto directo con el usuario es el controlador, llamado BankController. Su papel es similar al de un asistente en ventanilla: recibe las solicitudes del cliente, como abrir una cuenta, realizar depósitos, retirar fondos o revisar transacciones. El controlador no realiza las operaciones por sí mismo, sino que valida los datos básicos y luego los envía al servicio correspondiente, que es el encargado de ejecutar la lógica central. Esto permite mantener una separación clara entre la comunicación externa y las reglas internas del negocio.

La parte más importante de la aplicación está en la lógica de negocio, representada por la interfaz BankService y su clase de implementación BankServiceImpl. En este módulo se definen las reglas que determinan cómo deben comportarse las operaciones bancarias. Aquí se revisa que las cuentas existan, que los montos sean válidos, que haya fondos disponibles antes de realizar un retiro y que toda transacción cumpla con las normas del sistema. Si ocurre algo que no está permitido, se lanza una excepción personalizada, DomainException, que informa al usuario o al controlador del motivo del error.

El modelo del sistema agrupa las clases que representan los componentes reales del banco. La clase Customer describe a los clientes y almacena su información personal. Account funciona como la base para todos los tipos de cuentas, manejando el saldo y las operaciones comunes. A partir de ella se crean dos tipos concretos: CheckingAccount, que representa una cuenta corriente con un límite de sobregiro, y SavingsAccount, una cuenta de ahorro que puede generar intereses. Además, Transaction guarda el detalle de cada operación realizada y Money se utiliza para manejar las cantidades de dinero de forma precisa, evitando errores en cálculos.

El almacenamiento de los datos se realiza mediante el repositorio JsonRepository, que trabaja con archivos JSON ubicados en la carpeta de datos del proyecto. Esta clase se apoya en FileManager, que gestiona la lectura y escritura de los archivos, y en JsonUtil, que convierte los objetos Java en formato JSON y viceversa. Este tipo de persistencia es ideal para proyectos educativos o demostraciones, ya que permite conservar la información sin necesidad de una base de datos compleja. Sin embargo, en aplicaciones más grandes, sería conveniente reemplazarlo por un sistema de base de datos relacional o NoSQL.

Un aspecto técnico interesante del proyecto es el uso del patrón de diseño Strategy para calcular los intereses de las cuentas de ahorro. Mediante la interfaz InterestStrategy y las clases concretas SimpleRateStrategy y TieredRateStrategy, se pueden aplicar diferentes métodos de cálculo sin modificar el resto del sistema. Este enfoque hace que la aplicación sea más flexible y fácil de adaptar a distintos escenarios financieros.

En la carpeta de pruebas (src/test) se encuentra una clase que verifica que la aplicación arranca correctamente y que los componentes principales se comportan como se espera. Aunque las pruebas actuales son básicas, representan un punto de partida sólido para añadir más casos que validen operaciones como depósitos, retiros, transferencias y el guardado de datos.

En general, este proyecto representa una excelente base para aprender sobre la estructura de aplicaciones Java con Spring Boot. Se destacan buenas prácticas como la separación por capas, la aplicación del patrón Strategy y el manejo adecuado de excepciones. Además, su diseño modular facilita la ampliación de funciones, como agregar autenticación, validaciones más estrictas o migrar a una base de datos profesional en el futuro.
